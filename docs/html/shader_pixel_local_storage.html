<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Mali OpenGL ES SDK v2.4.4: Shader Pixel Local Storage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mali OpenGL ES SDK v2.4.4
<span id="malidevcenter"><a href="http://malideveloper.arm.com">Mali Developer Center</a></span>
   </div>
    <a id="eula" href="http://malideveloper.arm.com/develop-for-mali/mali-opengl-es-sdk-for-linux-end-user-licence-agreement-eula/
">Use of the code snippets present within these pages are subject to these EULA terms</a>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Help&#160;and&#160;Tutorials</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('shader_pixel_local_storage.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="class_shader.html">Shader</a> Pixel Local Storage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial demonstrates how a GPU can be used to implement deferred shading using the tile buffer available through the OpenGL ES 3.0 GL_SHADER_PIXEL_LOCAL_STORAGE_EXT extension. The tutorial also utilises the GL_ARM_shader_framebuffer_fetch_depth_stencil extension to restore an object's world position in the fragment shader. The Phong model is used for lighting scene objects.</p>
<div class="image">
<img src="ShaderPixelLocalStorage.png" alt="ShaderPixelLocalStorage.png"/>
</div>
<h1><a class="anchor" id="shaderPixelLocalStorageIntroduction"></a>
Introduction</h1>
<p>Deferred shading is a fairly widespread rendering technique nowadays. It is well described in various sources (<a href="#ref1">[1]</a>, <a href="#ref2">[2]</a>, <a href="#ref3">[3]</a>) and implemented in more than a dozen games <a href="#ref4">[4]</a>.</p>
<p>This technique appeared with the growth of scene complexities. First, let's review forward rendering. In a complex scene, multiple objects can be projected on the same screen fragment, but only one fragment is displayed: the one that is closest to the camera. Calculations done for all other fragments are discarded, thus wasting fragment shader processor resources. The problem becomes even worse with the growth of the number of lights in the scene, as the fragment shader must be run for each light in the scene. Here we also should keep in mind that many lights in the scene do not actually contribute to lighting the object's surface at all, as they are just too far from the illuminated fragment and thus their contribution is zero or negligable.</p>
<p>To overcome this problem, the deferred shading technique was introduced. The idea is quite simple: let's first find out which fragments will be displayed, and only then calculate their display properties. But here you might notice that we can only find out which fragments are displayed and which are discarded in the fragment shader, while the object properties required for lighting (like the world position and normal vector) are available in the previous graphics rendering pipeline stage - the vertex shader. This problem can be solved in a quite simple and obvious way: let's cache the required data for each fragment processed. Thankfully, because of the way the depth buffer works, we can store data for the closest fragment to the camera, and the data for occluded objects is automatically discarded.</p>
<p>Such an approach is implemented in the multiple render targets technique. The main idea of this technique is to output the required data into different texture targets, in order to store fragment properties. The set of three or four textures into which the data is output is called a G-Buffer. Most modern OpenGL ES implementations allow the rendering of a scene into up to four textures simultaneously, which is enough to store all the required data for the upcoming light calculations. Unfortunately, using multiple render targets has its own downsides. One of these is that now we output three or four times more data, which adds overhead to the GPU's memory bus.</p>
<p>Fortunately, the latest developments in OpenGL ES solve the problem <a href="#ref5">[5]</a>:</p>
<dl class="section note"><dt>Note</dt><dd>A major strength of Mali and other tile-based architectures is that a lot of operations can be performed on-chip without having to access external memory. For an application to run efficiently on such architectures it is beneficial to try and keep the processing on-chip for as long as possible. Flushing tile-buffer data to a framebuffer that is subsequently read by sampling a texture can be expensive and consume a lot of bandwidth.</dd>
<dd>
The extension [EXT_shader_pixel_local_storage], which is only available for OpenGL ES 3.0, provides a mechanism for applications to pass information between fragment shader invocations covering the same pixel.</dd></dl>
<p>In this tutorial we use the extension to keep data on the GPU during all three stages and we output the data into framebuffer memory only in the combination pass.</p>
<h1><a class="anchor" id="shaderPixelLocalStorageApplicationDesign"></a>
ApplicationDesign</h1>
<p>We render a scene with several spheres lying on a plane. The plane and each of the spheres are assigned a different colors. Several light sources move around the scene. The camera continuously moves over the scene, displaying the scene from various points of view.</p>
<p>To implement deferred shading we should implement following passes:</p>
<ul>
<li><b>G-Buffer generation pass</b> The G-Buffer generation pass renders the plane and spheres. The fragment closest to the camera has its parameters stored in pixel local storage.</li>
</ul>
<ul>
<li><b>Shading pass</b> The shading pass calculates lighting for fragments covered by the lighting source. The total accumulated lighting for the fragment is updated in pixel local storage.</li>
</ul>
<ul>
<li><b>Combination pass</b> The combination pass renders fragments onto the screen using color and lighting data stored in the fragment's pixel local storage.</li>
</ul>
<p>The above mentioned passes are present in all three main functions of the control program: in <b><a class="el" href="_shader_pixel_local_storage_8cpp.html#a8b7dfbcdb3dc83c1982777ee04068b17">setup_graphics()</a></b>, in <b><a class="el" href="_astc_textures_8cpp.html#a9d208c9398ed462c31771146011c45a6" title="Renders a single frame.">render_frame()</a></b> and in <b><a class="el" href="_metaballs_8cpp.html#a4b66d5e31b5dc18b314c8a68163263bd">cleanup()</a></b>. The <b><a class="el" href="_shader_pixel_local_storage_8cpp.html#a8b7dfbcdb3dc83c1982777ee04068b17">setup_graphics()</a></b> and <b><a class="el" href="_metaballs_8cpp.html#a4b66d5e31b5dc18b314c8a68163263bd">cleanup()</a></b> functions are largely standard and their code is well commented, so we will mostly discuss the rendering function and its three passes.</p>
<h1><a class="anchor" id="shaderPixelLocalStorageRenderingFunction"></a>
G-Buffer Generation Pass</h1>
<p>Besides three mentioned passes, the rendering function does few more things. At the start we calculate view-projection and inverted view-projection matrices, which will be used in two out of three stages:</p>
<div class="fragment"><div class="line"><span class="comment">/* We use it during gbuffer generation and shading passes. */</span></div>
<div class="line"><a class="code" href="_shader_pixel_local_storage_8cpp.html#a1440e8d995c32504f631ec9f28e28e64">calc_view_projection_matrices</a>(<a class="code" href="_metaballs_8cpp.html#a29fcba045d20605dc4bf39427d1c5757">model_time</a>, <a class="code" href="_shader_pixel_local_storage_8cpp.html#a20cd0bce4a7df2b5a0088f6618445092">matrix_view_projection</a>, <a class="code" href="_shader_pixel_local_storage_8cpp.html#aa08f6cfd4ea8a25e1e668630664cf0b4">matrix_view_projection_inverted</a>);</div>
</div><!-- fragment --><p>At the start of the rendering function we should enable the extension:</p>
<div class="fragment"><div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnable(<a class="code" href="_shader_pixel_local_storage_8cpp.html#aede032841eff8715045eb9d15619d20b">GL_SHADER_PIXEL_LOCAL_STORAGE_EXT</a>));</div>
</div><!-- fragment --><p>And at the end we should disable the extension:</p>
<div class="fragment"><div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDisable(<a class="code" href="_shader_pixel_local_storage_8cpp.html#aede032841eff8715045eb9d15619d20b">GL_SHADER_PIXEL_LOCAL_STORAGE_EXT</a>));</div>
</div><!-- fragment --><h1><a class="anchor" id="shaderPixelLocalStorageRenderingFunction"></a>
G-Buffer Generation Pass</h1>
<p>The vertex shader at this stage is rather regular: it transforms vertices using model-view-projection matrix and makes color and normal vectors accessible in fragment shader:</p>
<div class="fragment"><div class="line"><a class="code" href="gbuffer__generation__pass__shader_8frag.html#a0d470db12eb22b6c638b80c29bf8e4fc">vColor</a>        = <a class="code" href="structvec3.html">vec3</a>(<a class="code" href="gbuffer__generation__pass__shader_8vert.html#a87d9966b368e96468e5bd2b154c92285">uObjectColor</a>);</div>
<div class="line"><a class="code" href="gbuffer__generation__pass__shader_8frag.html#af078c305802664787c23c7738bb68016">vNormal</a>       = <a class="code" href="structvec3.html">vec3</a>(<a class="code" href="gbuffer__generation__pass__shader_8vert.html#aec05403b9bacc348dcaedbb8d8cf28a9">vObjectVertexNormal</a>);</div>
<div class="line">gl_Position   = <a class="code" href="gbuffer__generation__pass__shader_8vert.html#a88193d9c6d99814601130315cea0daed">uMVP</a> * <a class="code" href="structvec4.html">vec4</a>(<a class="code" href="gbuffer__generation__pass__shader_8vert.html#a096d7fcbf103f7283e87648b4770780f">vObjectVertexCoordinates</a>, 1.0);</div>
</div><!-- fragment --><p>The fragment shader is more interesting: at first we enable the extension:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#extension GL_EXT_shader_pixel_local_storage : require</span></div>
</div><!-- fragment --><p>Then we declare pixel local storage format structure (FragData) and a variable of this type (gbuf):</p>
<div class="fragment"><div class="line">__pixel_local_outEXT <a class="code" href="combination__pass__shader_8frag.html#a3057f4ff877485f38ed7c1058065207a">FragData</a></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="combination__pass__shader_8frag.html#a0c83b03caf87f268576f078475f0e03f">layout</a>(rgba8) highp <a class="code" href="structvec4.html">vec4</a> Color;</div>
<div class="line">    <a class="code" href="combination__pass__shader_8frag.html#a0c83b03caf87f268576f078475f0e03f">layout</a>(rg16f) highp <a class="code" href="structvec2.html">vec2</a> NormalXY;</div>
<div class="line">    <a class="code" href="combination__pass__shader_8frag.html#a0c83b03caf87f268576f078475f0e03f">layout</a>(rg16f) highp <a class="code" href="structvec2.html">vec2</a> NormalZ_LightingB;</div>
<div class="line">    <a class="code" href="combination__pass__shader_8frag.html#a0c83b03caf87f268576f078475f0e03f">layout</a>(rg16f) highp <a class="code" href="structvec2.html">vec2</a> LightingRG;</div>
<div class="line">} <a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>;</div>
</div><!-- fragment --><p>Now in the G-Buffer generation pass each fragment has a variable gbuf. The feature of gbuf is that the values written into it in this fragment shader are preserved and are avaliable in the fragment shader of the next two passes, thus making values shared among fragment shaders of other passes. The format of the structure (fields, their names and types, as well as field order) should be the same in all other shaders. The only token allowed to be different in the structure declaration is the qualifier. During the pass we used __pixel_local_outEXT, becuase we only need to write into the pixel local storage. According to <a href="#ref5">[5]</a>, the following new qualifiers are introduced by the extension:</p>
<table class="doxtable">
<tr>
<th>Qualifier </th><th>Storage access</th></tr>
<tr>
<td>pixel_local_EXT </td><td>Storage can be read and written to </td></tr>
<tr>
<td>pixel_local_inEXT </td><td>Storage can be read from </td></tr>
<tr>
<td>pixel_local_outEXT </td><td>Storage can be written to </td></tr>
</table>
<p>The other two qualifiers we use in the shading and combination pass fragment shaders. Now lets take a look at the fields stored in gbuf. Although there are four fields in gbuf, we actually store three values in them: fragment color, fragment normal vector and the lighting accumulator. We have to split the normal and lighting vectors into two parts and store the third component of each in the NormalZ_LightingB field of gbuf. It would be easier to use normal and lighting vectors as <a class="el" href="structvec3.html">vec3</a> variables, but we are very limited in the types available for fields in pixel local storage <a href="#ref5">[5]</a>:</p>
<table class="doxtable">
<tr>
<th>Layout </th><th>Base type</th></tr>
<tr>
<td>r32ui </td><td>uint </td></tr>
<tr>
<td>r11f_g11f_b10f </td><td><a class="el" href="structvec3.html">vec3</a> </td></tr>
<tr>
<td>r32f </td><td>float </td></tr>
<tr>
<td>rg16f </td><td><a class="el" href="structvec2.html">vec2</a> </td></tr>
<tr>
<td>rgb10_a2 </td><td><a class="el" href="structvec4.html">vec4</a> </td></tr>
<tr>
<td>rgba8 </td><td><a class="el" href="structvec4.html">vec4</a> </td></tr>
<tr>
<td>rg16 </td><td><a class="el" href="structvec2.html">vec2</a> </td></tr>
<tr>
<td>rgba8i </td><td>ivec4 </td></tr>
<tr>
<td>rg16i </td><td>ivec2 </td></tr>
<tr>
<td>rgb10_a2ui </td><td>uvec4 </td></tr>
<tr>
<td>rgba8ui </td><td>uvec4 </td></tr>
<tr>
<td>rg16ui </td><td><a class="el" href="structuvec2.html">uvec2</a> </td></tr>
</table>
<p>The only <a class="el" href="structvec3.html">vec3</a> available has quite low precision (approximately 2.5 decimal digits <a href="#ref6">[6]</a>) and cannot even contain negative values, making interaction with such <a class="el" href="structvec3.html">vec3</a> fields even more complicated. Currently the amount of data available for pixel local storage is limited to 128 bits (16 bytes) per fragment. That's why we cannot declare normal and colors as a set of r32f float per-component fields. The total number of bytes available in pixel local storage can be obtained by calling the glGetInteger function with a pname of GL_SHADER_PIXEL_LOCAL_STORAGE_EXT, or can be read in the fragment shader from constant int gl_MaxShaderPixelLocalStorageSizeEXT <a href="#ref7">[7]</a>.</p>
<p>The usage of gbuf during the G-Buffer generation pass is quite straightforward. We just store fragment color and normal, and set the lighting accumulator to zero:</p>
<div class="fragment"><div class="line"><span class="comment">/* Store primitive color. */</span></div>
<div class="line"><a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.Color                = <a class="code" href="structvec4.html">vec4</a>(<a class="code" href="gbuffer__generation__pass__shader_8frag.html#a0d470db12eb22b6c638b80c29bf8e4fc">vColor</a>, 0.0);</div>
<div class="line"><span class="comment">/* Store normal vector. */</span></div>
<div class="line"><a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.NormalXY             = <a class="code" href="gbuffer__generation__pass__shader_8frag.html#af078c305802664787c23c7738bb68016">vNormal</a>.xy;</div>
<div class="line"><a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.NormalZ_LightingB[0] = <a class="code" href="gbuffer__generation__pass__shader_8frag.html#af078c305802664787c23c7738bb68016">vNormal</a>.<a class="code" href="structvec3.html#aa76213efcc5d656cc14b71db80a92162">z</a>;</div>
<div class="line"><span class="comment">/* Reserve and set lighting to 0. */</span></div>
<div class="line"><a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.LightingRG           = <a class="code" href="structvec2.html">vec2</a>(0.0);</div>
<div class="line"><a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.NormalZ_LightingB[1] = 0.0;</div>
</div><!-- fragment --><p>Some work is assigned to be done by the depth buffer, which is enabled at the end of the control program <a class="el" href="_shader_pixel_local_storage_8cpp.html#a8b7dfbcdb3dc83c1982777ee04068b17">setup_graphics()</a> function:</p>
<div class="fragment"><div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDisable(GL_BLEND));</div>
<div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnable(GL_DEPTH_TEST));</div>
</div><!-- fragment --><p>This enables us to use the depth test to store information in the tile buffer about the fragment closest to the camera. We'll need to activate it for the G-Buffer generation pass:</p>
<div class="fragment"><div class="line"><span class="comment">/* Only the fragment closest to the camera will be stored in the tile buffer. */</span></div>
<div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDepthMask(GL_TRUE));</div>
</div><!-- fragment --><p>The rendering of the primitives is quite straightforward and the code is well commented, so we'll only roughly review it here. First, we render the plane:</p>
<div class="fragment"><div class="line"><span class="comment">/* Attach mesh vertices and normals to appropriate shader attributes. */</span></div>
<div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer(<a class="code" href="_shader_pixel_local_storage_8cpp.html#aebec7928a31426d18b433bd4626e24d4">gbuffer_generation_pass_vertex_coordinates_location</a>, 3, GL_FLOAT, GL_FALSE, 0, &amp;<a class="code" href="_shader_pixel_local_storage_8cpp.html#a2eca46e151f106e9e44a0b0aebf55dd2">plane_mesh_vertices</a>[0]));</div>
<div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer(<a class="code" href="_shader_pixel_local_storage_8cpp.html#a342db67bb85ef4c98e8d6c9c79ad67b4">gbuffer_generation_pass_vertex_normal_location</a>,      3, GL_FLOAT, GL_FALSE, 0, &amp;<a class="code" href="_shader_pixel_local_storage_8cpp.html#a007ed028da0583de9570b80cb2c4dc43">plane_mesh_normals</a>[0] ));</div>
<div class="line"><span class="comment">/* Specify a model-view-projection matrix. The model matrix is an identity matrix for the plane, so we can save one multiplication for the pass. */</span></div>
<div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="_shader_pixel_local_storage_8cpp.html#ad30261555ad8a9e8a5c20d03113d7d36">gbuffer_generation_pass_mvp_matrix_location</a>,            1, GL_FALSE, <a class="code" href="_shader_pixel_local_storage_8cpp.html#a20cd0bce4a7df2b5a0088f6618445092">matrix_view_projection</a>.getAsArray()));</div>
<div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform3f(<a class="code" href="_shader_pixel_local_storage_8cpp.html#a720d5394524e9a0b6a93ab5e27fd9fc6">gbuffer_generation_pass_object_color_location</a>, <a class="code" href="_shader_pixel_local_storage_8cpp.html#ac4148603d4622260173d7ec49d943447">plane_color_r</a>, <a class="code" href="_shader_pixel_local_storage_8cpp.html#a1ff6cc2d7cc15a838da1400d97ec9bf0">plane_color_g</a>, <a class="code" href="_shader_pixel_local_storage_8cpp.html#a6a163e64f884c30b61e45e87c677817d">plane_color_b</a>));</div>
<div class="line"><span class="comment">/* Execute shader to render the plane into pixel storage. */</span></div>
<div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawArrays(GL_TRIANGLES, 0, (GLsizei)<a class="code" href="_shader_pixel_local_storage_8cpp.html#a2eca46e151f106e9e44a0b0aebf55dd2">plane_mesh_vertices</a>.size()/3));</div>
</div><!-- fragment --><p>Next, we render the spheres in the loop in a similar way:</p>
<div class="fragment"><div class="line"><span class="comment">/* Attach mesh vertices and normals to appropriate shader attributes. */</span></div>
<div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer(<a class="code" href="_shader_pixel_local_storage_8cpp.html#aebec7928a31426d18b433bd4626e24d4">gbuffer_generation_pass_vertex_coordinates_location</a>, 3, GL_FLOAT, GL_FALSE, 0, &amp;<a class="code" href="_shader_pixel_local_storage_8cpp.html#a9c06b1ccfc93e8895482930bee0d8042">sphere_mesh_vertices</a>[0]));</div>
<div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer(<a class="code" href="_shader_pixel_local_storage_8cpp.html#a342db67bb85ef4c98e8d6c9c79ad67b4">gbuffer_generation_pass_vertex_normal_location</a>,      3, GL_FLOAT, GL_FALSE, 0, &amp;<a class="code" href="_shader_pixel_local_storage_8cpp.html#a6d8dab5f1a88cb9847a72f1e433b81da">sphere_mesh_normals</a>[0] ));</div>
<div class="line"><span class="comment">/* Render each sphere on the scene in its position, size and color. */</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="_shader_pixel_local_storage_8cpp.html#ad444c6a6a8b2db6be28a01bcd15dc0ad">spheres_array_size</a>; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Calculate and set the MVP matrix for the sphere. Apply scaling and translation to sphere. */</span></div>
<div class="line">    <a class="code" href="_shader_pixel_local_storage_8cpp.html#a6c14fa41f14df84cd438cc606cd44f84">matrix_mvp</a> = <a class="code" href="_shader_pixel_local_storage_8cpp.html#a20cd0bce4a7df2b5a0088f6618445092">matrix_view_projection</a> * <a class="code" href="_shader_pixel_local_storage_8cpp.html#a54f3127019f9bc39713402b96696a0a2">calc_model_matrix</a>(<a class="code" href="_shader_pixel_local_storage_8cpp.html#a4bcfe49ad26c14054eacea540183c706">spheres_array</a>[i].<a class="code" href="instancing_2assets_2vertex__shader__source_8vert.html#aa54ed43d51780722b88e8009cb628beb">radius</a>, <a class="code" href="class_vec3f.html" title="A 3D floating point vector.">Vec3f</a>(<a class="code" href="_shader_pixel_local_storage_8cpp.html#a4bcfe49ad26c14054eacea540183c706">spheres_array</a>[i].x, <a class="code" href="_shader_pixel_local_storage_8cpp.html#a4bcfe49ad26c14054eacea540183c706">spheres_array</a>[i].y, <a class="code" href="_shader_pixel_local_storage_8cpp.html#a4bcfe49ad26c14054eacea540183c706">spheres_array</a>[i].z));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="_shader_pixel_local_storage_8cpp.html#a0f39aa0b8db704ef8d3ae0deacadcdbf">shading_pass_mvp_matrix_location</a>, 1, GL_FALSE, <a class="code" href="_shader_pixel_local_storage_8cpp.html#a6c14fa41f14df84cd438cc606cd44f84">matrix_mvp</a>.getAsArray()));</div>
<div class="line">    <span class="comment">/* Set MVP matrix and sphere color for the shader. */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="_shader_pixel_local_storage_8cpp.html#ad30261555ad8a9e8a5c20d03113d7d36">gbuffer_generation_pass_mvp_matrix_location</a>, 1, GL_FALSE, <a class="code" href="_shader_pixel_local_storage_8cpp.html#a6c14fa41f14df84cd438cc606cd44f84">matrix_mvp</a>.getAsArray()));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform3f(<a class="code" href="_shader_pixel_local_storage_8cpp.html#a720d5394524e9a0b6a93ab5e27fd9fc6">gbuffer_generation_pass_object_color_location</a>, <a class="code" href="_shader_pixel_local_storage_8cpp.html#a4bcfe49ad26c14054eacea540183c706">spheres_array</a>[i].r, <a class="code" href="_shader_pixel_local_storage_8cpp.html#a4bcfe49ad26c14054eacea540183c706">spheres_array</a>[i].g, <a class="code" href="_shader_pixel_local_storage_8cpp.html#a4bcfe49ad26c14054eacea540183c706">spheres_array</a>[i].b));</div>
<div class="line">    <span class="comment">/* Execute shader to render sphere into pixel local storage. */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawArrays(GL_TRIANGLES, 0, (GLsizei)<a class="code" href="_shader_pixel_local_storage_8cpp.html#a9c06b1ccfc93e8895482930bee0d8042">sphere_mesh_vertices</a>.size()/3));</div>
<div class="line">}</div>
</div><!-- fragment --><p>In first two lines, we specify where the vertices and normals are stored. These are common for all spheres, and the sphere size and sphere location are applied to the sphere via the model matrix returned by calc_model_matrix. This function combines scaling and translation to zoom out and move an identity sphere from the origin point into the point specified by spheres_array[i].xyz .</p>
<h1><a class="anchor" id="shaderPixelLocalStorageShadingPass"></a>
Shading pass</h1>
<p>The light sources (which in real life are often of spherical shape) are rendered here as cubic objects (light boxes), because it is easier to render a cube rather than a sphere. If a light box has a size equal to the light source diameter, all fragments influenced by the light source are inside that light box. Some extra fragments, which are covered by the light box, but not covered by the sphere are not influenced by the light due to distance.</p>
<p>Let's first review the control program part:</p>
<div class="fragment"><div class="line"><span class="comment">/* Attach the mesh vertices to the appropriate shader attribute. */</span></div>
<div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer(<a class="code" href="_shader_pixel_local_storage_8cpp.html#a66ce2583ae21c00dd8d5256782c224ef">shading_pass_lightbox_vertex_coordinates_location</a>, 3, GL_FLOAT, GL_FALSE, 0, &amp;<a class="code" href="_shader_pixel_local_storage_8cpp.html#a9007070204580f07476f6a8ae49a6fad">cube_mesh_vertices</a>[0]));</div>
<div class="line"><span class="comment">/* Process each light&#39;s bounding box on the scene in its position, size and color. */</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="_shader_pixel_local_storage_8cpp.html#a3409965e62d1a3a59a434836765bd3fe">lights_array_size</a>; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Calculate the light position for the current time. */</span></div>
<div class="line">    <a class="code" href="class_vec3f.html" title="A 3D floating point vector.">Vec3f</a> light_position = <a class="code" href="_shader_pixel_local_storage_8cpp.html#a738553f3df0dbdffacb07659a2ca7f3a">calculate_light_position</a>(<a class="code" href="_metaballs_8cpp.html#a29fcba045d20605dc4bf39427d1c5757">model_time</a>, <a class="code" href="_shader_pixel_local_storage_8cpp.html#ae4cbcbfac39f2874483cbc55f1c52ef8">lights_array</a>[i].orbit_height, <a class="code" href="_shader_pixel_local_storage_8cpp.html#ae4cbcbfac39f2874483cbc55f1c52ef8">lights_array</a>[i].orbit_radius, <a class="code" href="_shader_pixel_local_storage_8cpp.html#ae4cbcbfac39f2874483cbc55f1c52ef8">lights_array</a>[i].angle_speed);</div>
<div class="line">    <span class="comment">/* Determine light box size. To avoid interference with the frustum it cannot be large than the scene. */</span></div>
<div class="line">    <span class="keywordtype">float</span> light_box_size = <a class="code" href="_shader_pixel_local_storage_8cpp.html#ae4cbcbfac39f2874483cbc55f1c52ef8">lights_array</a>[i].<a class="code" href="structlight__properties__type.html#af990ffd354896699f25913f70cdbad64">light_radius</a> &gt; 1.0f ? 1.0f : <a class="code" href="_shader_pixel_local_storage_8cpp.html#ae4cbcbfac39f2874483cbc55f1c52ef8">lights_array</a>[i].<a class="code" href="structlight__properties__type.html#af990ffd354896699f25913f70cdbad64">light_radius</a>;</div>
<div class="line">    <span class="comment">/* Calculate and set MVP matrix for the light box. Apply scaling and translation. */</span></div>
<div class="line">    <a class="code" href="_shader_pixel_local_storage_8cpp.html#a6c14fa41f14df84cd438cc606cd44f84">matrix_mvp</a> = <a class="code" href="_shader_pixel_local_storage_8cpp.html#a20cd0bce4a7df2b5a0088f6618445092">matrix_view_projection</a> * <a class="code" href="_shader_pixel_local_storage_8cpp.html#a54f3127019f9bc39713402b96696a0a2">calc_model_matrix</a>(light_box_size, light_position);</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="_shader_pixel_local_storage_8cpp.html#a0f39aa0b8db704ef8d3ae0deacadcdbf">shading_pass_mvp_matrix_location</a>, 1, GL_FALSE, <a class="code" href="_shader_pixel_local_storage_8cpp.html#a6c14fa41f14df84cd438cc606cd44f84">matrix_mvp</a>.getAsArray()));</div>
<div class="line">    <span class="comment">/* Set the light radius, the light position and its color for the shading pass program. */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform1f(<a class="code" href="_shader_pixel_local_storage_8cpp.html#a47521b1dad8ec4a2d94f1bfedc8d7181">shading_pass_light_radius_location</a>,      <a class="code" href="_shader_pixel_local_storage_8cpp.html#ae4cbcbfac39f2874483cbc55f1c52ef8">lights_array</a>[i].light_radius));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform3f(<a class="code" href="_shader_pixel_local_storage_8cpp.html#a2c00fbe98974adf9af937b40d8b5056a">shading_pass_light_color_location</a>,       <a class="code" href="_shader_pixel_local_storage_8cpp.html#ae4cbcbfac39f2874483cbc55f1c52ef8">lights_array</a>[i].r, <a class="code" href="_shader_pixel_local_storage_8cpp.html#ae4cbcbfac39f2874483cbc55f1c52ef8">lights_array</a>[i].g, <a class="code" href="_shader_pixel_local_storage_8cpp.html#ae4cbcbfac39f2874483cbc55f1c52ef8">lights_array</a>[i].b));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform3f(<a class="code" href="_shader_pixel_local_storage_8cpp.html#a1fdd700769f270a2ccf9721f5540ab72">shading_pass_light_coordinates_location</a>, light_position.<a class="code" href="class_vec3f.html#a4ee774446db3cafa0f9682065a64ba32">x</a>,  light_position.<a class="code" href="class_vec3f.html#a3b01268bf88a45f95a45097b0457393f">y</a>,  light_position.<a class="code" href="class_vec3f.html#a78f2ea154cc9996ad95397a1fb0f4033">z</a> ));</div>
<div class="line">    <span class="comment">/* Execute the shader to light up fragments in the light box of the pixel storage. */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawArrays(GL_TRIANGLES, 0, (GLsizei)<a class="code" href="_shader_pixel_local_storage_8cpp.html#a9007070204580f07476f6a8ae49a6fad">cube_mesh_vertices</a>.size()/3));</div>
<div class="line">}</div>
</div><!-- fragment --><p>You might notice that it is rather similar to the part of the G-Buffer generation in the control program responsible for rendering the plane and spheres. The only thing worth noticing is that we apply the same transformations to light boxes as we applied to the spheres and plane. Thus it might look like an attempt to display these light boxes in fragments which might be occupied by plane or sphere surfaces. But instead we do this only to invoke the shading pass fragment shader for the fragments under the light box (fragments which might be illuminated by the light). Also, because lighting has an accumulative nature, we should run the fragment shader for every fragment, even if the shader was processed by another shader run from another light. To achieve this, we should disable depth buffer:</p>
<div class="fragment"><div class="line"><span class="comment">/* This pass should not update depths, only use them. */</span></div>
<div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDepthMask(GL_FALSE));</div>
</div><!-- fragment --><p>Now let's review the shaders that make up this pass. The vertex shader is even shorter than the G-Buffer generation pass vertex shader, so we won't review it here. What's most interesting for us is the fragment shader. The fragment shader implements regular diffuse Phong lighting, but the data is extracted from various sources. At the beginning of the fragment shader we enable two extensions:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#extension GL_EXT_shader_pixel_local_storage : require</span></div>
<div class="line"><span class="preprocessor">#extension GL_ARM_shader_framebuffer_fetch_depth_stencil : require</span></div>
</div><!-- fragment --><p>We already reviewed the pixel storage extension in the previous pass. The second extension GL_ARM_shader_framebuffer_fetch_depth_stencil enables us to have an access to the gl_LastFragDepthARM built in variable, which contains fragment depth. In combination with the gl_FragCoord and inverted viewprojection vector we can calculate all three components of the clip coordinates:</p>
<div class="fragment"><div class="line">ClipCoord.xy               = gl_FragCoord.xy * <a class="code" href="shading__pass__shader_8frag.html#ab3431f3fbefa1beed8484e36d8739eef">uInvViewport</a>;</div>
<div class="line">ClipCoord.z                = gl_LastFragDepthARM;</div>
<div class="line">ClipCoord.w                = 1.0;</div>
<div class="line">ClipCoord                  = ClipCoord * 2.0 - 1.0;</div>
</div><!-- fragment --><p>With the clip coordinates and inverted view-projection matrix (calculated in the control program and transferred into shader using a uniform) we can find out the world space of the currently running fragment:</p>
<div class="fragment"><div class="line"><a class="code" href="structvec4.html">vec4</a> worldPosition         = ClipCoord * <a class="code" href="shading__pass__shader_8frag.html#a9e167d0db9a53c8b113fef66c858034b">uInvViewProj</a>;</div>
<div class="line">worldPosition             /= worldPosition.<a class="code" href="structvec4.html#a0c92fe67e490d9768217a00c2e8abd49">w</a>;</div>
</div><!-- fragment --><p>Having the world position and light position (transferred into the shader as a uniform), we can calculate a light vector and strength (as a lightVectorLength):</p>
<div class="fragment"><div class="line"><a class="code" href="structvec3.html">vec3</a> lightVector           = <a class="code" href="shading__pass__shader_8frag.html#aa56325f7f12aecc0bee1a1ef98b33c38">uLightPos</a> - worldPosition.<a class="code" href="structvec4.html#a7393f7525715d33e4dc5b79ebeb275fb">xyz</a>;</div>
<div class="line"><span class="keywordtype">float</span> lightVectorLength    = length(lightVector);</div>
<div class="line">lightVector               /= lightVectorLength;</div>
</div><!-- fragment --><p>We're missing the normal vector, which we unpack from pixel local storage:</p>
<div class="fragment"><div class="line"><a class="code" href="structvec3.html">vec3</a> normalVector          = <a class="code" href="structvec3.html">vec3</a>(<a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.NormalXY, <a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.NormalZ_LightingB[0]);</div>
</div><!-- fragment --><p>After that, we can calculate conventional Phong lighting parameters like light attenuation (lightAttenuation) and the dot product of the light and normal vectors (normalDotLightVector):</p>
<p>Now we have all the required data to compute fragment lighting for the texel:</p>
<div class="fragment"><div class="line"><a class="code" href="structvec3.html">vec3</a> texelLighting         = <a class="code" href="structvec3.html">vec3</a>(<a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.LightingRG, <a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.NormalZ_LightingB[1]);</div>
<div class="line">texelLighting             += <a class="code" href="shading__pass__shader_8frag.html#a97361b0379f895daccefd57bf64a08ce">uLightColor</a> * normalDotLightVector * lightAttenuation;</div>
<div class="line"><a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.LightingRG            = texelLighting.rg;</div>
<div class="line"><a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.NormalZ_LightingB[1]  = texelLighting.b;</div>
</div><!-- fragment --><p>The lighting share of the light for the fragment processed is calculated at the second line of the code. The first line and last two lines do lighting packing to and unpacking from the pixel local storage. Beacuse we do not only read the values from the pixel local storage, but also write the values into it, we declare the buffer accessible for reading and writing:</p>
<div class="fragment"><div class="line">__pixel_localEXT <a class="code" href="combination__pass__shader_8frag.html#a3057f4ff877485f38ed7c1058065207a">FragData</a></div>
</div><!-- fragment --><h1><a class="anchor" id="shaderPixelLocalStorageCombinationPass"></a>
Combination pass</h1>
<p>At the combination pass, we render the data gathered in pixel local storage onto the screen. The control program of this pass is rather simple. It invokes the pass' shader program four times:</p>
<div class="fragment"><div class="line"><span class="comment">/* Activate this pass&#39; program. */</span></div>
<div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUseProgram(<a class="code" href="_shader_pixel_local_storage_8cpp.html#a44896b0927b229b821385f6ab9c0c19c">combination_pass_program_id</a>));</div>
<div class="line"><span class="comment">/* Render a fullscreen quad, so that each fragment has a chance to be updated with data from local pixel storage. */</span></div>
<div class="line"><a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawArrays(GL_TRIANGLE_STRIP, 0, <a class="code" href="_shader_pixel_local_storage_8cpp.html#a76ecf5e6125d97e5a5d4aeae51de1dc8">full_quad_vertex_count</a>));</div>
</div><!-- fragment --><p>The vertex shader outputs a so-called "fullscreen quad". In our program it consists of two triangles:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span>(gl_VertexID)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">case</span> 0: gl_Position = <a class="code" href="structvec4.html">vec4</a>( 1.0,  1.0, -1.0, 1.0); <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> 1: gl_Position = <a class="code" href="structvec4.html">vec4</a>(-1.0,  1.0, -1.0, 1.0); <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> 2: gl_Position = <a class="code" href="structvec4.html">vec4</a>( 1.0, -1.0, -1.0, 1.0); <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> 3: gl_Position = <a class="code" href="structvec4.html">vec4</a>(-1.0, -1.0, -1.0, 1.0); <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>These two triangles cover the whole viewport (screen surface) and force the combination pass fragment shader to be run for every pixel. The fragment shader is rather simple, it reads the accumulated lighting and fragment color:</p>
<div class="fragment"><div class="line"><a class="code" href="structvec3.html">vec3</a> diffuseColor  = <a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.Color.xyz;</div>
<div class="line"><a class="code" href="structvec3.html">vec3</a> texelLighting = <a class="code" href="structvec3.html">vec3</a>(<a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.LightingRG, <a class="code" href="combination__pass__shader_8frag.html#a1dd6082eecddc1b9377087690e5bd877">gbuf</a>.NormalZ_LightingB[1]);</div>
</div><!-- fragment --><p>Then the fragment shader calculates the fragment color and writes it to the output variable fragColor, thus rendering it onto screen:</p>
<div class="fragment"><div class="line"><span class="comment">/* This will effectively write the color data to the native framebuffer</span></div>
<div class="line"><span class="comment">   format of the currently attached color attachment.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><a class="code" href="boids_2assets_2fragment__shader__source_8frag.html#a6d8dd0540ed9af35f34cd31b838cacce">fragColor</a>          = <a class="code" href="structvec4.html">vec4</a>(diffuseColor * texelLighting, 1.0);</div>
</div><!-- fragment --><p>Because in this shader we only read gbuf, we use an appropriate qualifier in the gbuf declaration:</p>
<div class="fragment"><div class="line">__pixel_local_inEXT <a class="code" href="combination__pass__shader_8frag.html#a3057f4ff877485f38ed7c1058065207a">FragData</a></div>
</div><!-- fragment --><h1><a class="anchor" id="shaderPixelLocalStorageConclusion"></a>
Conclusion</h1>
<p>In this tutorial we gave an overview of the new extension that enables us to perform operations on the GPU without the need to transfer data from and to external memory. We also demonstrate how deferred shading can be implemented with this new feature in mind. Of course, the most important thing is the performance we can achieve using the new extension (<a href="#ref5">[5]</a> "Breakdown of graph data showing a 9x bandwidth reduction").</p>
<h1><a class="anchor" id="shaderPixelLocalStorageReferences"></a>
References</h1>
<p><a class="anchor" id="ref1"></a>[1] <a href="http://ogldev.atspace.co.uk/www/tutorial35/tutorial35.html">http://ogldev.atspace.co.uk/www/tutorial35/tutorial35.html</a></p>
<p><a class="anchor" id="ref2"></a>[2] <a href="http://http.download.nvidia.com/developer/presentations/2004/6800_Leagues/6800_Leagues_Deferred_Shading.pdf">http://http.download.nvidia.com/developer/presentations/2004/6800_Leagues/6800_Leagues_Deferred_Shading.pdf</a></p>
<p><a class="anchor" id="ref3"></a>[3] <a href="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch19.html">http://http.developer.nvidia.com/GPUGems3/gpugems3_ch19.html</a></p>
<p><a class="anchor" id="ref4"></a>[4] <a href="http://en.wikipedia.org/wiki/Deferred_shading#Deferred_shading_in_commercial_games">http://en.wikipedia.org/wiki/Deferred_shading#Deferred_shading_in_commercial_games</a></p>
<p><a class="anchor" id="ref5"></a>[5] Bandwidth Efficient Graphics with ARM® Mali GPUs. Marius Bjørge, ARM</p>
<p><a class="anchor" id="ref6"></a>[6] <a href="https://www.opengl.org/wiki/Small_Float_Formats">https://www.opengl.org/wiki/Small_Float_Formats</a></p>
<p><a class="anchor" id="ref7"></a>[7] <a href="https://www.opengl.org/registry/specs/EXT/shader_pixel_local_storage.txt">https://www.opengl.org/registry/specs/EXT/shader_pixel_local_storage.txt</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2013</a>
    </li>
  </ul>
</div>
</body>
</html>
