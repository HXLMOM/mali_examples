<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Mali OpenGL ES SDK v2.4.4: Projected Lights</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mali OpenGL ES SDK v2.4.4
<span id="malidevcenter"><a href="http://malideveloper.arm.com">Mali Developer Center</a></span>
   </div>
    <a id="eula" href="http://malideveloper.arm.com/develop-for-mali/mali-opengl-es-sdk-for-linux-end-user-licence-agreement-eula/
">Use of the code snippets present within these pages are subject to these EULA terms</a>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li class="current"><a href="pages.html"><span>Help&#160;and&#160;Tutorials</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('projected_lights.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Projected Lights </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Projected Lights effect using OpenGL ES 3.0.</p>
<h1><a class="anchor" id="projectedLightsIntroduction"></a>
Introduction</h1>
<p>This tutorial assumes that you already have basic OpenGL ES knowledge, and have read and understood the <a class="el" href="shadow_mapping.html">Shadow Mapping</a> tutorial.</p>
<h1><a class="anchor" id="projectedLightsOverview"></a>
Overview</h1>
<div class="image">
<img src="ProjectedLights.png" alt="ProjectedLights.png"/>
<div class="caption">
Projected Lights effect: the direction of the projected lights changes during rendering.</div></div>
<p> The application shows the projected lights effect. There is a spot light effect adjusted to display the texture instead of the normal light colour. There is also a shadow map technique used to make the scene more realistic by applying some shadows.</p>
<p>The projected lights effect is implemented in two basic steps, described below:</p>
<ul>
<li>Calculating the shadow map.<ul>
<li>The scene is rendered from spot light's point of view.</li>
<li>The result is stored in the depth texture, which is called a <em>shadow map</em>.</li>
<li>The shadow map will be used in next steps to verify whether a fragment should be lit by the spot light or should be obscured by shadow.</li>
</ul>
</li>
<li><a class="el" href="class_scene.html">Scene</a> rendering.<ul>
<li>The scene (which consists of a plane, on top of which is placed a single cube) is rendered from camera's point of view.</li>
<li>Directional lighting is implemented to accentuate the 3D scene with the perspective.</li>
<li>A spot light effect is implemented, however it is adjusted to display texture rather than a simple colour.</li>
<li>Shadows are computed for the spot lighting (the result of the first step is now used).</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="projectedLightsRenderGeometry"></a>
Render geometry</h1>
<p>In the application we are rendering a horizontally located plane, on top of which we lay a single cube. Let us now focus on the geneating the geometry that will be rendered.</p>
<div class="image">
<img src="ProjectedLightsGeometry.png" alt="ProjectedLightsGeometry.png"/>
<div class="caption">
Vertex coordinates of the geometry that will be rendered.</div></div>
<p> First of all, we need to have the coordinates of vertices that make up a cubic or plane shape. Please note that there will also be lighting applied, which means that we will need normals as well.</p>
<p>Geometry data will be stored and then used by objects that are generated with the following commands:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Generate buffer objects. */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenBuffers(1, &amp;<a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.coordinatesBufferObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenBuffers(1, &amp;<a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.normalsBufferObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenBuffers(1, &amp;<a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.coordinatesBufferObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenBuffers(1, &amp;<a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.normalsBufferObjectId));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Generate vertex array objects. */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenVertexArrays(1, &amp;<a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.vertexArrayObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenVertexArrays(1, &amp;<a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.vertexArrayObjectId));</div>
</div><!-- fragment --><p> Geometry data is then generated and copied to specific buffer objects. For more details of how the coordinates of vertices are calculated, please refer to the implementation of those functions.</p>
<div class="fragment"><div class="line"><span class="comment">/* Please see the specification above. */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="_projected_lights_8cpp.html#a8b381d688c25708f984193fd02de4d24" title="Prepare the geometry data that will be used while rendering the scene.">setupGeometryData</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Get triangular representation of the scene cube. Store the data in the cubeCoordinates array. */</span></div>
<div class="line">    <a class="code" href="class_cube_model.html#a34ca93a380960f6b6f74ef400ab95d5a" title="Compute coordinates of points which make up a ube shape.">CubeModel::getTriangleRepresentation</a>(&amp;<a class="code" href="_projected_lights_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a72a03d4df0859c1806b38607560764f2">coordinates</a>,</div>
<div class="line">                                         &amp;<a class="code" href="_projected_lights_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a>,</div>
<div class="line">                                          <a class="code" href="_projected_lights_8h.html#a81f5339488d01568b19db90e599fcddf">CUBE_SCALING_FACTOR</a>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Calculate normal vectors for the scene cube created above. */</span></div>
<div class="line">    <a class="code" href="class_cube_model.html#a444c75aa60708e889b7bd129f1e82f9b" title="Create normals for a cube.">CubeModel::getNormals</a>(&amp;<a class="code" href="_projected_lights_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a12cdb7164e0cd608b6eaf7eee6c85925">normals</a>,</div>
<div class="line">                          &amp;<a class="code" href="_projected_lights_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#aa7fcd7a4c103ff663038ad907b4cebb0">numberOfElementsInNormalsArray</a>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Get triangular representation of a square to draw plane in XZ space. Store the data in the planeCoordinates array. */</span></div>
<div class="line">    <a class="code" href="class_plane_model.html#a55728e7a362980aeef9c2d5562365494" title="Get coordinates of points which make up a plane. The plane is located in XZ space.">PlaneModel::getTriangleRepresentation</a>(&amp;<a class="code" href="_projected_lights_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a72a03d4df0859c1806b38607560764f2">coordinates</a>,</div>
<div class="line">                                          &amp;<a class="code" href="_projected_lights_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a>,</div>
<div class="line">                                           <a class="code" href="_projected_lights_8h.html#a65dd2111a731c31a9409b72e6808a7b8">PLANE_SCALING_FACTOR</a>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Calculate normal vectors for the plane. Store the data in the planeNormals array. */</span></div>
<div class="line">    <a class="code" href="class_plane_model.html#ac1bd7195b5e4fb1d411233a98f28f8b8" title="Get normals for plane placed in XZ space.">PlaneModel::getNormals</a>(&amp;<a class="code" href="_projected_lights_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a12cdb7164e0cd608b6eaf7eee6c85925">normals</a>,</div>
<div class="line">                           &amp;<a class="code" href="_projected_lights_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#aa7fcd7a4c103ff663038ad907b4cebb0">numberOfElementsInNormalsArray</a>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Fill buffer objects with data. */</span></div>
<div class="line">    <span class="comment">/* Buffer holding coordinates of triangles which make up the scene cubes. */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div>
<div class="line">                          <a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.coordinatesBufferObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div>
<div class="line">                          <a class="code" href="_projected_lights_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a> * <span class="keyword">sizeof</span>(GLfloat),</div>
<div class="line">                          <a class="code" href="_projected_lights_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a72a03d4df0859c1806b38607560764f2">coordinates</a>,</div>
<div class="line">                          GL_STATIC_DRAW));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Buffer holding coordinates of normal vectors for each vertex of the scene cubes. */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div>
<div class="line">                          <a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.normalsBufferObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div>
<div class="line">                          <a class="code" href="_projected_lights_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#aa7fcd7a4c103ff663038ad907b4cebb0">numberOfElementsInNormalsArray</a> * <span class="keyword">sizeof</span>(GLfloat),</div>
<div class="line">                          <a class="code" href="_projected_lights_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a12cdb7164e0cd608b6eaf7eee6c85925">normals</a>,</div>
<div class="line">                          GL_STATIC_DRAW));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Buffer holding coordinates of triangles which make up the plane. */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div>
<div class="line">                          <a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.coordinatesBufferObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div>
<div class="line">                          <a class="code" href="_projected_lights_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a> * <span class="keyword">sizeof</span>(GLfloat),</div>
<div class="line">                          <a class="code" href="_projected_lights_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a72a03d4df0859c1806b38607560764f2">coordinates</a>,</div>
<div class="line">                          GL_STATIC_DRAW));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Buffer holding coordinates of the plane&#39;s normal vectors. */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer(GL_ARRAY_BUFFER,</div>
<div class="line">                          <a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.normalsBufferObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBufferData(GL_ARRAY_BUFFER,</div>
<div class="line">                          <a class="code" href="_projected_lights_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#aa7fcd7a4c103ff663038ad907b4cebb0">numberOfElementsInNormalsArray</a> * <span class="keyword">sizeof</span>(GLfloat),</div>
<div class="line">                          <a class="code" href="_projected_lights_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a12cdb7164e0cd608b6eaf7eee6c85925">normals</a>,</div>
<div class="line">                          GL_STATIC_DRAW));</div>
<div class="line">}</div>
</div><!-- fragment --><p> In the program object, geometry vertices are referred to via the attributes, which is rather obvious.</p>
<div class="fragment"><div class="line"><span class="comment">/* ATTRIBUTES */</span></div>
<div class="line">in <a class="code" href="structvec4.html">vec4</a> <a class="code" href="render__scene__shader_8vert.html#a37dc370ff582ccd2f4051538cf014d50">vertexCoordinates</a>; <span class="comment">/* Attribute: holding coordinates of triangles that make up a geometry. */</span></div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> <a class="code" href="render__scene__shader_8vert.html#a6922a321d19db971c71acd3c28c36403">vertexNormals</a>;     <span class="comment">/* Attribute: holding normals. */</span></div>
</div><!-- fragment --><p> This is why we need to query for the attribute location within the program object responsible for scene rendering (note that all of the following functions need to be called for the active program object).</p>
<div class="fragment"><div class="line">    locationsStoragePtr-&gt;attributeVertexCoordinates            = <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetAttribLocation   (programObjectId, <span class="stringliteral">&quot;vertexCoordinates&quot;</span>));</div>
<div class="line">    locationsStoragePtr-&gt;attributeVertexNormals                = <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetAttribLocation   (programObjectId, <span class="stringliteral">&quot;vertexNormals&quot;</span>));</div>
</div><!-- fragment --><p> As you can see above, we are querying for the coordinates only, without specifying the cube or plane ones. This is because we are using only one program object to render both the plane and cube. Rendering specific geometry is achieved by using proper <em><a class="el" href="struct_vertex.html">Vertex</a> Attrib Arrays</em>. Let's look at how it is implemented.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Enable cube VAAs. */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindVertexArray        (<a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.vertexArrayObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER,</div>
<div class="line">                                       <a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.coordinatesBufferObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexCoordinates,</div>
<div class="line">                                       <a class="code" href="samples_2opengles__30_2projected__lights_2_mathematics_8h.html#a6065b2906f66d7d9fc2d23aca7da604d" title="Number of coordinates for a point in 3D space.">NUMBER_OF_POINT_COORDINATES</a>,</div>
<div class="line">                                       GL_FLOAT,</div>
<div class="line">                                       GL_FALSE,</div>
<div class="line">                                       0,</div>
<div class="line">                                       NULL));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER,</div>
<div class="line">                                       <a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.normalsBufferObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexNormals,</div>
<div class="line">                                       <a class="code" href="samples_2opengles__30_2projected__lights_2_mathematics_8h.html#a6065b2906f66d7d9fc2d23aca7da604d" title="Number of coordinates for a point in 3D space.">NUMBER_OF_POINT_COORDINATES</a>,</div>
<div class="line">                                       GL_FLOAT,</div>
<div class="line">                                       GL_FALSE,</div>
<div class="line">                                       0,</div>
<div class="line">                                       NULL));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexCoordinates));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexNormals));</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Enable plane VAAs. */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindVertexArray        (<a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.vertexArrayObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER,</div>
<div class="line">                                       <a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.coordinatesBufferObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexCoordinates,</div>
<div class="line">                                       <a class="code" href="samples_2opengles__30_2projected__lights_2_mathematics_8h.html#a6065b2906f66d7d9fc2d23aca7da604d" title="Number of coordinates for a point in 3D space.">NUMBER_OF_POINT_COORDINATES</a>,</div>
<div class="line">                                       GL_FLOAT,</div>
<div class="line">                                       GL_FALSE,</div>
<div class="line">                                       0,</div>
<div class="line">                                       NULL));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindBuffer             (GL_ARRAY_BUFFER,</div>
<div class="line">                                       <a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.normalsBufferObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glVertexAttribPointer    (<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexNormals,</div>
<div class="line">                                       <a class="code" href="samples_2opengles__30_2projected__lights_2_mathematics_8h.html#a6065b2906f66d7d9fc2d23aca7da604d" title="Number of coordinates for a point in 3D space.">NUMBER_OF_POINT_COORDINATES</a>,</div>
<div class="line">                                       GL_FLOAT,</div>
<div class="line">                                       GL_FALSE,</div>
<div class="line">                                       0,</div>
<div class="line">                                       NULL));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexCoordinates));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnableVertexAttribArray(<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.attributeVertexNormals));</div>
</div><!-- fragment --><p> And now, by calling <em>glBindVertexArray()</em> with the proper parameter, we can control which object: cube or plane is going to be rendered. Please refer to:</p>
<div class="fragment"><div class="line">        <span class="comment">/* Set cube&#39;s coordinates to be used within a program object. */</span></div>
<div class="line">        <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindVertexArray(<a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderCube.vertexArrayObjectId));</div>
</div><!-- fragment --><div class="fragment"><div class="line">        <span class="comment">/* Set plane&#39;s coordinates to be used within a program object. */</span></div>
<div class="line">        <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindVertexArray(<a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.renderPlane.vertexArrayObjectId));</div>
</div><!-- fragment --><p> The final thing is to make the actual draw call, which can be achieved by:</p>
<div class="fragment"><div class="line">        <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawArrays(GL_TRIANGLES,</div>
<div class="line">                              0,</div>
<div class="line">                              <a class="code" href="_projected_lights_8cpp.html#a318b6a66ee0718cc5aa3bc2710216958">cubeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a> / <a class="code" href="samples_2opengles__30_2projected__lights_2_mathematics_8h.html#a6065b2906f66d7d9fc2d23aca7da604d" title="Number of coordinates for a point in 3D space.">NUMBER_OF_POINT_COORDINATES</a>));</div>
</div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glDrawArrays(GL_TRIANGLES,</div>
<div class="line">                              0,</div>
<div class="line">                              <a class="code" href="_projected_lights_8cpp.html#ac9ab497ae8937a42fda382b616e73361">planeGeometryProperties</a>.<a class="code" href="struct_geometry_properties.html#a0944e2a4f3522045706744e9c1637f88">numberOfElementsInCoordinatesArray</a> / <a class="code" href="samples_2opengles__30_2projected__lights_2_mathematics_8h.html#a6065b2906f66d7d9fc2d23aca7da604d" title="Number of coordinates for a point in 3D space.">NUMBER_OF_POINT_COORDINATES</a>));</div>
</div><!-- fragment --> <h1><a class="anchor" id="projectedLightsShadowMapping"></a>
Calculate a shadow map</h1>
<p>To calculate the shadow map we need to create a depth texture, which will be used to store the results. It is achieved in some basic steps, which you should already know, but let us describe this one more time.</p>
<p>Generate texture object and bind it to the <em>GL_TEXTURE_2D</em> target.</p>
<div class="fragment"><div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenTextures  (1,</div>
<div class="line">                            &amp;<a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.depthTextureObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture  (GL_TEXTURE_2D,</div>
<div class="line">                             <a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.depthTextureObjectId));</div>
</div><!-- fragment --><p> Specify the texture storage data type.</p>
<div class="fragment"><div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexStorage2D(GL_TEXTURE_2D,</div>
<div class="line">                            1,</div>
<div class="line">                            GL_DEPTH_COMPONENT24,</div>
<div class="line">                            <a class="code" href="_projected_lights_8h.html#a33c035cd444cd612486a2dc35c8d1028">SHADOW_MAP_TEXTURE_WIDTH</a>,</div>
<div class="line">                            <a class="code" href="_projected_lights_8h.html#a06cbd47b23e5463561b05eed434dc9eb">SHADOW_MAP_TEXTURE_HEIGHT</a>));</div>
</div><!-- fragment --><p> We wanted our shadow to be more precise, this is why the depth texture resolution is bigger than normal scene size. Please refer to:</p>
<div class="fragment"><div class="line"></div>
<div class="line"><span class="preprocessor">    #define WINDOW_HEIGHT (600)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">    #define WINDOW_WIDTH (600)</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"></div>
<div class="line"><span class="preprocessor">    #define SHADOW_MAP_TEXTURE_HEIGHT (2400)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">    #define SHADOW_MAP_TEXTURE_WIDTH (2400)</span></div>
</div><!-- fragment --><p> Set texture object parameters. The new thing here is to set <em>GL_TEXTURE_COMPARE_MODE</em> to the value of <em>GL_COMPARE_REF_TO_TEXTURE</em> which leads to r texture coordinate to be compared to the value in the currently bound depth texture.</p>
<div class="fragment"><div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_MIN_FILTER,</div>
<div class="line">                             GL_LINEAR));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_MAG_FILTER,</div>
<div class="line">                             GL_LINEAR));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_WRAP_S,</div>
<div class="line">                             GL_CLAMP_TO_EDGE));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_WRAP_T,</div>
<div class="line">                             GL_CLAMP_TO_EDGE));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_WRAP_R,</div>
<div class="line">                             GL_CLAMP_TO_EDGE));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_COMPARE_FUNC,</div>
<div class="line">                             GL_LEQUAL));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_COMPARE_MODE,</div>
<div class="line">                             GL_COMPARE_REF_TO_TEXTURE));</div>
</div><!-- fragment --><p> The next thing we have to do to implement the <em>render to texture</em> mechanism is to:</p>
<ul>
<li>Generate framebuffer object.</li>
</ul>
<div class="fragment"><div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenFramebuffers     (1,</div>
<div class="line">                                   &amp;<a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.framebufferObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindFramebuffer     (GL_FRAMEBUFFER,</div>
<div class="line">                                    <a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.framebufferObjectId));</div>
</div><!-- fragment --><ul>
<li>Bind the depth texture object to the depth attachment of the framebuffer object.</li>
</ul>
<div class="fragment"><div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glFramebufferTexture2D(GL_FRAMEBUFFER,</div>
<div class="line">                                    GL_DEPTH_ATTACHMENT,</div>
<div class="line">                                    GL_TEXTURE_2D,</div>
<div class="line">                                    <a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.depthTextureObjectId,</div>
<div class="line">                                    0));</div>
</div><!-- fragment --><p> We have to use proper <em>view-projection matrices</em> while rendering. It is important to mention here that our spot light position is constant during the rendering process, but its direction is changing, which means the point at which the spot light is directed is updated per frame.</p>
<div class="fragment"><div class="line">        <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix                = Matrix::matrixPerspective(<a class="code" href="namespace_mali_s_d_k.html#a683f8db3cdf4522a549aa6b237661df4" title="Convert an angle in degrees to radians.">degreesToRadians</a>(<a class="code" href="_projected_lights_8h.html#af637b1de3e6848ae304138c3e6662b8e">LIGHT_PERSPECTIVE_FOV_IN_DEGREES</a>),</div>
<div class="line">                                                                                        1.0f,</div>
<div class="line">                                                                                        <a class="code" href="_projected_lights_8h.html#a2a63d0f9e8c8889d4fdd2b668c23c289">NEAR_PLANE</a>,</div>
<div class="line">                                                                                        <a class="code" href="_projected_lights_8h.html#ae69d04c4d256d9db0ff98b5c97646a80">FAR_PLANE</a>);</div>
</div><!-- fragment --><div class="fragment"><div class="line"></div>
<div class="line"><span class="comment">/* Please see the specification above. */</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="_projected_lights_8cpp.html#a9c77072116f3207d39b6316ef0619a2e" title="Calculate the updated direction of the spot light and update the corresponding OpenGLES object settin...">updateSpotLightDirection</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Time used to set light direction and position. */</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> currentAngle = <a class="code" href="_astc_textures_8cpp.html#aaf7e0389622e8f7b78393ee10d8e93a4">timer</a>.getTime() / 4.0f;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Update the look at point coordinates. */</span></div>
<div class="line">    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint.x = <a class="code" href="_projected_lights_8h.html#a9194ff982aa795cad37fb21d65415668">SPOT_LIGHT_TRANSLATION_RADIUS</a> * sinf(currentAngle);</div>
<div class="line">    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint.y = -1.0f;</div>
<div class="line">    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint.z = <a class="code" href="_projected_lights_8h.html#a9194ff982aa795cad37fb21d65415668">SPOT_LIGHT_TRANSLATION_RADIUS</a> * cosf(currentAngle);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Update all the view, projection matrixes athat are connected with updated look at point coordinates. */</span></div>
<div class="line">    <a class="code" href="class_vec4f.html" title="A 4D floating point vector.">Vec4f</a> <a class="code" href="_shadow_mapping_8cpp.html#a69769a55c91bfb010df17d90dea68ab3">lookAtPoint</a> = {<a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint.x,</div>
<div class="line">                         <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint.y,</div>
<div class="line">                         <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint.z,</div>
<div class="line">                         1.0f};</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Get lookAt matrix from the light&#39;s point of view, directed at the center of a plane.</span></div>
<div class="line"><span class="comment">     * Store result in viewMatrixForShadowMapPass. */</span></div>
<div class="line">    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix = Matrix::matrixLookAt(<a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.position,</div>
<div class="line">                                                          <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.lookAtPoint,</div>
<div class="line">                                                          <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.upVector);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.modelViewMatrix            = <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix * <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.modelMatrix;</div>
<div class="line">    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.modelViewMatrix           = <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix * <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.modelMatrix;</div>
<div class="line">    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.modelViewProjectionMatrix  = <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix * <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.modelViewMatrix;</div>
<div class="line">    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.modelViewProjectionMatrix = <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix * <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.modelViewMatrix;</div>
<div class="line">    <a class="code" href="_projected_lights_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.spotLightLookAtPointInEyeSpace               = Matrix::vertexTransform(&amp;lookAtPoint, &amp;<a class="code" href="_projected_lights_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.viewMatrix);</div>
<div class="line"></div>
<div class="line">    Matrix inverseCameraViewMatrix       = Matrix::matrixInvert(&amp;<a class="code" href="_projected_lights_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.viewMatrix);</div>
<div class="line">    <span class="comment">/* [Define colour texture translation matrix] */</span></div>
<div class="line">    Matrix colorTextureTranslationMatrix = Matrix::createTranslation(<a class="code" href="_projected_lights_8h.html#aa7137159324fb5e2be36540ffad79d59">COLOR_TEXTURE_TRANSLATION</a>,</div>
<div class="line">                                                                     0.0f,</div>
<div class="line">                                                                     <a class="code" href="_projected_lights_8h.html#aa7137159324fb5e2be36540ffad79d59">COLOR_TEXTURE_TRANSLATION</a>);</div>
<div class="line">    <span class="comment">/* [Define colour texture translation matrix] */</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">/* [Calculate matrix for shadow map sampling: colour texture] */</span></div>
<div class="line">    <a class="code" href="_projected_lights_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.viewToColorTextureMatrix = Matrix::biasMatrix                   *</div>
<div class="line">                                                    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix *</div>
<div class="line">                                                    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix       *</div>
<div class="line">                                                    colorTextureTranslationMatrix        *</div>
<div class="line">                                                    inverseCameraViewMatrix;</div>
<div class="line">    <span class="comment">/* [Calculate matrix for shadow map sampling: colour texture] */</span></div>
<div class="line">    <span class="comment">/* [Calculate matrix for shadow map sampling: depth texture] */</span></div>
<div class="line">    <a class="code" href="_projected_lights_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.viewToDepthTextureMatrix = Matrix::biasMatrix                   *</div>
<div class="line">                                                    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix *</div>
<div class="line">                                                    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix       *</div>
<div class="line">                                                    inverseCameraViewMatrix;</div>
<div class="line">    <span class="comment">/* [Calculate matrix for shadow map sampling: depth texture] */</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> There are different matrices used for rendering cube and plane form spot light point of view. Call <em>glUniformMatrix4fv()</em> to update the uniform values. </p>
<div class="fragment"><div class="line">            <span class="comment">/* Use matrices specific for rendering a scene from spot light perspective. */</span></div>
<div class="line">            <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformModelViewMatrix,</div>
<div class="line">                                        1,</div>
<div class="line">                                        GL_FALSE,</div>
<div class="line">                                        <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.modelViewMatrix.getAsArray()));</div>
<div class="line">            <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformModelViewProjectionMatrix,</div>
<div class="line">                                        1,</div>
<div class="line">                                        GL_FALSE,</div>
<div class="line">                                        <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.modelViewProjectionMatrix.getAsArray()));</div>
<div class="line">            <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformNormalMatrix,</div>
<div class="line">                                        1,</div>
<div class="line">                                        GL_FALSE,</div>
<div class="line">                                        <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.cubeViewProperties.normalMatrix.getAsArray()));</div>
</div><!-- fragment --><div class="fragment"><div class="line">            <span class="comment">/* Use matrices specific for rendering a scene from spot light perspective. */</span></div>
<div class="line">            <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformModelViewMatrix,</div>
<div class="line">                                        1,</div>
<div class="line">                                        GL_FALSE,</div>
<div class="line">                                        <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.modelViewMatrix.getAsArray()));</div>
<div class="line">            <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformModelViewProjectionMatrix,</div>
<div class="line">                                        1,</div>
<div class="line">                                        GL_FALSE,</div>
<div class="line">                                        <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.modelViewProjectionMatrix.getAsArray()));</div>
<div class="line">            <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniformMatrix4fv(<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformNormalMatrix,</div>
<div class="line">                                        1,</div>
<div class="line">                                        GL_FALSE,</div>
<div class="line">                                        <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.planeViewProperties.normalMatrix.getAsArray()));</div>
</div><!-- fragment --><p> Owing to the fact that the shadow map texture is bigger than the normal scene (as already mentioned above), we have to remember to adjust the viewport.</p>
<div class="fragment"><div class="line">        <span class="comment">/* Set the view port to size of shadow map texture. */</span></div>
<div class="line">        <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glViewport(0, 0, <a class="code" href="_projected_lights_8h.html#a33c035cd444cd612486a2dc35c8d1028">SHADOW_MAP_TEXTURE_WIDTH</a>, <a class="code" href="_projected_lights_8h.html#a06cbd47b23e5463561b05eed434dc9eb">SHADOW_MAP_TEXTURE_HEIGHT</a>));</div>
</div><!-- fragment --><p> Our scene is rather simple: there is only one cube placed on the top of a plane. We can introduce some optimisation here, which means the back faces will be culled. We are also setting the polygon offset to eliminate z-fighting in the shadows. Those settings are used only if enabled.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Set the Polygon offset, used when rendering the into the shadow map</span></div>
<div class="line"><span class="comment">     * to eliminate z-fighting in the shadows (if enabled). */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glPolygonOffset(1.0f, 0.0f));</div>
<div class="line">    <span class="comment">/* Set back faces to be culled (only when GL_CULL_FACE mode is enabled). */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glCullFace(GL_BACK));</div>
</div><!-- fragment --><div class="fragment"><div class="line">        <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnable(GL_POLYGON_OFFSET_FILL));</div>
</div><!-- fragment --><p> What we need to do is to enable depth testing. When this is enabled, the depth values will be compared and the result will be stored in the depth buffer. </p>
<div class="fragment"><div class="line">    <span class="comment">/* Enable depth test to do comparison of depth values. */</span></div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glEnable(GL_DEPTH_TEST));</div>
</div><!-- fragment --><p> In this step, we want to generate the depth values only, which means we are allowed to disable writing to each framebuffer colour component.</p>
<div class="fragment"><div class="line">        <span class="comment">/* Disable writing of each frame buffer colour component. */</span></div>
<div class="line">        <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE));</div>
</div><!-- fragment --><p> Finally we are ready for the actual rendering.</p>
<div class="fragment"><div class="line">        <a class="code" href="_projected_lights_8cpp.html#ae1c4792a30e6f97a1200800f5ef6dd08" title="Draw cube and plane model.">drawCubeAndPlane</a>(<span class="keyword">false</span>);</div>
</div><!-- fragment --><p> If we would like to use the generated depth texture data in a program object, it is enough to query for a shadow sampler uniform location and set the depth texture object as input value for this uniform.</p>
<div class="fragment"><div class="line">    locationsStoragePtr-&gt;uniformShadowMap                      = <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetUniformLocation  (programObjectId, <span class="stringliteral">&quot;shadowMap&quot;</span>));</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glActiveTexture(GL_TEXTURE0 + <a class="code" href="_projected_lights_8h.html#abf6d8d3afe888d4e24bf78d0e32402d3">TEXTURE_UNIT_FOR_SHADOW_MAP_TEXTURE</a>));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture  (GL_TEXTURE_2D,</div>
<div class="line">                             <a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.depthTextureObjectId));</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform1i       (<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformShadowMap,</div>
<div class="line">                                <a class="code" href="_projected_lights_8h.html#abf6d8d3afe888d4e24bf78d0e32402d3">TEXTURE_UNIT_FOR_SHADOW_MAP_TEXTURE</a>));</div>
</div><!-- fragment --><p> More details about the program object and the scene rendering will be described in the following sections: <a class="el" href="projected_lights.html#projectedLightsGeneraeColorTexture">Generate and use colour texture</a> and <a class="el" href="projected_lights.html#projectedLightsProjectingTexture">Projecting a texture</a>.</p>
<h1><a class="anchor" id="projectedLightsGeneraeColorTexture"></a>
Generate and use colour texture</h1>
<p>There is a colour texture projected onto the scene, which is why we need to generate a texture object filled with data. This is achieved in some basic steps as described below.</p>
<div class="image">
<img src="ProjectedLightsTexture.bmp" alt="ProjectedLightsTexture.bmp"/>
<div class="caption">
Image that will be projected onto a screen.</div></div>
<p> Set active texture unit for colour texture. </p>
<div class="fragment"><div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glActiveTexture(GL_TEXTURE0 + <a class="code" href="_projected_lights_8h.html#a4ef1e331f4c66eef9de854a40986936f">TEXTURE_UNIT_FOR_COLOR_TEXTURE</a>));</div>
</div><!-- fragment --><p> Generate and bind texture object.</p>
<div class="fragment"><div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGenTextures  (1,</div>
<div class="line">                            &amp;<a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.colorTextureObjectId));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glBindTexture  (GL_TEXTURE_2D,</div>
<div class="line">                             <a class="code" href="_projected_lights_8cpp.html#a2a7ab786d8ee80485d590cd1e336986c">renderSceneObjects</a>.colorTextureObjectId));</div>
</div><!-- fragment --><p> Load BMP image data.</p>
<div class="fragment"><div class="line">    Texture::loadBmpImageData(<a class="code" href="_projected_lights_8h.html#aa30c0728c53a13bb1aca00543e8d0a0c">COLOR_TEXTURE_NAME</a>, &amp;imageWidth, &amp;imageHeight, &amp;textureData);</div>
</div><!-- fragment --><p> Set texture object data.</p>
<div class="fragment"><div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexStorage2D (GL_TEXTURE_2D,</div>
<div class="line">                             1,</div>
<div class="line">                             GL_RGB8,</div>
<div class="line">                             imageWidth,</div>
<div class="line">                             imageHeight));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexSubImage2D(GL_TEXTURE_2D,</div>
<div class="line">                             0,</div>
<div class="line">                             0,</div>
<div class="line">                             0,</div>
<div class="line">                             imageWidth,</div>
<div class="line">                             imageHeight,</div>
<div class="line">                             GL_RGB,</div>
<div class="line">                             GL_UNSIGNED_BYTE,</div>
<div class="line">                             textureData));</div>
</div><!-- fragment --><p> Set texture object parameters.</p>
<div class="fragment"><div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_MIN_FILTER,</div>
<div class="line">                             GL_LINEAR));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_MAG_FILTER,</div>
<div class="line">                             GL_LINEAR));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_WRAP_R,</div>
<div class="line">                             GL_REPEAT));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_WRAP_S,</div>
<div class="line">                             GL_REPEAT));</div>
<div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glTexParameteri(GL_TEXTURE_2D,</div>
<div class="line">                             GL_TEXTURE_WRAP_T,</div>
<div class="line">                             GL_REPEAT));</div>
</div><!-- fragment --><p> Now, if we would like to use the texture within the program object, we need to query for the colour texture object uniform sampler location (note that following commands are called for active program object).</p>
<div class="fragment"><div class="line">    locationsStoragePtr-&gt;uniformColorTexture                   = <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glGetUniformLocation  (programObjectId, <span class="stringliteral">&quot;colorTexture&quot;</span>));</div>
</div><!-- fragment --><p> Then we are ready to associate uniform sampler with texture object by calling</p>
<div class="fragment"><div class="line">    <a class="code" href="simple__framework_2inc_2_platform_8h.html#a5d9574303c254cdd7639476d1cec8f36">GL_CHECK</a>(glUniform1i       (<a class="code" href="_projected_lights_8cpp.html#afcbb5f20f07d128c4ef5f65da6855a15">renderSceneProgramLocations</a>.uniformColorTexture,</div>
<div class="line">                                <a class="code" href="_projected_lights_8h.html#a4ef1e331f4c66eef9de854a40986936f">TEXTURE_UNIT_FOR_COLOR_TEXTURE</a>));</div>
</div><!-- fragment --> <h1><a class="anchor" id="projectedLightsProjectingTexture"></a>
Projecting a texture</h1>
<p>Finally, we are ready to describe the mechanism of projecting a texture.</p>
<p>If you follow the instructions described in the previous sections (<a class="el" href="projected_lights.html#projectedLightsRenderGeometry">Render geometry</a>, <a class="el" href="projected_lights.html#projectedLightsShadowMapping">Calculate a shadow map</a>, <a class="el" href="projected_lights.html#projectedLightsGeneraeColorTexture">Generate and use colour texture</a>) you will be ready to focus on the projected lights mechanism.</p>
<p>We are using only one program object in this tutorial. The vertex shader is rather simple (presented below). It is used for translating coordinates into eye- and NDC-space (which is the eye-space with the perspective applied).</p>
<div class="fragment"><div class="line"><span class="comment">/* [Define attributes] */</span></div>
<div class="line"><span class="comment">/* ATTRIBUTES */</span></div>
<div class="line">in <a class="code" href="structvec4.html">vec4</a> <a class="code" href="render__scene__shader_8vert.html#a37dc370ff582ccd2f4051538cf014d50">vertexCoordinates</a>; <span class="comment">/* Attribute: holding coordinates of triangles that make up a geometry. */</span></div>
<div class="line">in <a class="code" href="structvec3.html">vec3</a> <a class="code" href="render__scene__shader_8vert.html#a6922a321d19db971c71acd3c28c36403">vertexNormals</a>;     <span class="comment">/* Attribute: holding normals. */</span></div>
<div class="line"><span class="comment">/* [Define attributes] */</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* UNIFORMS */</span></div>
<div class="line"><a class="code" href="glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structmat4.html">mat4</a> <a class="code" href="etc2__texture__demo_2assets_2vertex__shader__source_8vert.html#a5e6969c9c6ce1443f7dc50222103c308">modelViewMatrix</a>;           <span class="comment">/* Model * View matrix */</span></div>
<div class="line"><a class="code" href="glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structmat4.html">mat4</a> <a class="code" href="_integer_logics_8cpp.html#abfde23d4df05d4b1e08a72c631314bc0">modelViewProjectionMatrix</a>; <span class="comment">/* Model * View * Projection matrix */</span></div>
<div class="line"><a class="code" href="glutil_8cpp.html#a2c5c3c4ce30783b590dd30b1060b7b38">uniform</a> <a class="code" href="structmat4.html">mat4</a> <a class="code" href="render__scene__shader_8vert.html#a81f796db8a1c3681fb3eee2ca9d59d26">normalMatrix</a>;              <span class="comment">/* transpose(inverse(Model * View)) matrix */</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* OUTPUTS */</span></div>
<div class="line">out <a class="code" href="structvec3.html">vec3</a> <a class="code" href="render__scene__shader_8frag.html#a08509e9aaf0c6b2d3822d45337e2fa62">normalInEyeSpace</a>; <span class="comment">/* Normal vector for the coordinates. */</span></div>
<div class="line">out <a class="code" href="structvec4.html">vec4</a> <a class="code" href="render__scene__shader_8frag.html#ad30d70f8f7dda21aec3d393073308afe">vertexInEyeSpace</a>; <span class="comment">/* Vertex coordinates expressed in eye space. */</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="simple__framework_2fonts_2opengles__20_2font_8frag.html#acdef7a1fd863a6d3770c1268cb06add3">main</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Calculate and set output vectors. */</span></div>
<div class="line">    normalInEyeSpace = mat3x3(normalMatrix) * <a class="code" href="render__scene__shader_8vert.html#a6922a321d19db971c71acd3c28c36403">vertexNormals</a>;</div>
<div class="line">    vertexInEyeSpace = modelViewMatrix      * <a class="code" href="render__scene__shader_8vert.html#a37dc370ff582ccd2f4051538cf014d50">vertexCoordinates</a>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Multiply model-space coordinates by model-view-projection matrix to bring them into eye-space. */</span></div>
<div class="line">    gl_Position = modelViewProjectionMatrix * <a class="code" href="render__scene__shader_8vert.html#a37dc370ff582ccd2f4051538cf014d50">vertexCoordinates</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Please note that depth values are calculated from spot light's point of view. If we would like to use them while rendering the scene from camera's point of view, we would have to apply a translation from one space to another. Please look at the schema below.</p>
<div class="image">
<img src="ProjectedLightsMatrixSchema.png" alt="ProjectedLightsMatrixSchema.png"/>
<div class="caption">
Camera and spot light spaces schema.</div></div>
<p> Our shadow map (the texture object containing depth values) is computed in spot light's NDC space, however we would need depth values in camera eye space. To achieve that, we would take a fragment from camera eye space and translate it to spot light NDC space in order to query for its depth value. We need to calculate a matrix which will help us with that. The idea is marked at the schema with red arrows.</p>
<div class="fragment"><div class="line">    <a class="code" href="_projected_lights_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.viewToDepthTextureMatrix = Matrix::biasMatrix                   *</div>
<div class="line">                                                    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix *</div>
<div class="line">                                                    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix       *</div>
<div class="line">                                                    inverseCameraViewMatrix;</div>
</div><!-- fragment --><p> The bias matrix is used to map values from a range &lt;-1, 1&gt; (eye space coordinates) to &lt;0, 1&gt; (texture coordinates).</p>
<div class="fragment"><div class="line">    <span class="comment">/* Bias matrix. */</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> Matrix::biasArray[16] =</div>
<div class="line">    {</div>
<div class="line">        0.5f, 0.0f, 0.0f, 0.0f,</div>
<div class="line">        0.0f, 0.5f, 0.0f, 0.0f,</div>
<div class="line">        0.0f, 0.0f, 0.5f, 0.0f,</div>
<div class="line">        0.5f, 0.5f, 0.5f, 1.0f,</div>
<div class="line">    };</div>
</div><!-- fragment --><p> Analogous mechanism need to be used for sampling the colour texture. The only difference is that we want to fit the colour texture in the view, so that the texture is smaller and repeated multiple times.</p>
<div class="fragment"><div class="line">    Matrix colorTextureTranslationMatrix = Matrix::createTranslation(<a class="code" href="_projected_lights_8h.html#aa7137159324fb5e2be36540ffad79d59">COLOR_TEXTURE_TRANSLATION</a>,</div>
<div class="line">                                                                     0.0f,</div>
<div class="line">                                                                     <a class="code" href="_projected_lights_8h.html#aa7137159324fb5e2be36540ffad79d59">COLOR_TEXTURE_TRANSLATION</a>);</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="_projected_lights_8cpp.html#a29aefb3e58b40faf2ca6a8490f29aa02">cameraViewProperties</a>.viewToColorTextureMatrix = Matrix::biasMatrix                   *</div>
<div class="line">                                                    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.projectionMatrix *</div>
<div class="line">                                                    <a class="code" href="_projected_lights_8cpp.html#a0fb0abb8340523d2a30c4388f2cc0eed">lightViewProperties</a>.viewMatrix       *</div>
<div class="line">                                                    colorTextureTranslationMatrix        *</div>
<div class="line">                                                    inverseCameraViewMatrix;</div>
</div><!-- fragment --><p> In the fragment shader, we are dealing with two types of lighting:</p>
<ul>
<li>Directional lighting, which is implemented as presented below. We will not focus on this type of lighting here, as it should be already well known to a reader. If not, please refer to previous tutorials.</li>
</ul>
<div class="fragment"><div class="line"></div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> <a class="code" href="render__scene__shader_8frag.html#a9afbfa295215d0ba9356f8f424936814" title="Get the directional lighting factor.">calculateDirectionalLight</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a>  normalizedNormal         = <a class="code" href="matrix_8h.html#afec26b6e42064ef2316f1be013515801">normalize</a>(normalInEyeSpace);</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a>  normalizedLightDirection = <a class="code" href="matrix_8h.html#afec26b6e42064ef2316f1be013515801">normalize</a>(<a class="code" href="render__scene__shader_8frag.html#ab5751b09fd3a447f2391652b94fda6e8">directionalLightPosition</a> - vertexInEyeSpace.xyz);</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a>  result                   = <a class="code" href="structvec4.html">vec4</a>(<a class="code" href="render__scene__shader_8frag.html#abc84ff69edff6fd80b0944f55fd0c08f">directionalLightColor</a>, 1.0) * <a class="code" href="noise_8cpp.html#ad65e2a8f3578ef8c9af35582c57aca61">max</a>(dot(normalizedNormal, normalizedLightDirection), 0.0);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> result * <a class="code" href="render__scene__shader_8frag.html#aeb5b453745ccc9ea0710b6772f6525d2">directionalLightAmbient</a>;</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>Spot lighting, which is the same as projected texturing and will be now explained in more details.</li>
</ul>
<p>First of all, we need to verify whether the fragment is placed inside or outside the spot light cone. This is checked by calculating the angle between the vector from light source to the fragment and vector from light source to point into which light is directed. If the anngle is bigger than the spot light angle, it means the fragment is outside the spot light cone, if smaller - inside.</p>
<div class="fragment"><div class="line"></div>
<div class="line"><span class="keywordtype">float</span> <a class="code" href="render__scene__shader_8frag.html#a20c5b017814ec3143629dfefc7b60ca9" title="Get cosine of the angle between the current fragment and spot light direction.">getFragmentToLightCosValue</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a>  fragmentToLightdirection = <a class="code" href="matrix_8h.html#afec26b6e42064ef2316f1be013515801">normalize</a>(vertexInEyeSpace - <a class="code" href="render__scene__shader_8frag.html#ac9bf33d38dd684aa1d831d66b38168f9">spotLightPositionInEyeSpace</a>);</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a>  spotLightDirection       = <a class="code" href="matrix_8h.html#afec26b6e42064ef2316f1be013515801">normalize</a>(<a class="code" href="render__scene__shader_8frag.html#aa01d9d0e08884426b1ad4ffacd2393e0">spotLightLookAtPointInEyeSpace</a>- <a class="code" href="render__scene__shader_8frag.html#ac9bf33d38dd684aa1d831d66b38168f9">spotLightPositionInEyeSpace</a>);</div>
<div class="line">    <span class="keywordtype">float</span> cosine                   = dot(spotLightDirection, fragmentToLightdirection);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> cosine;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The next step is to verify whether the fragment should be shadowed or lit by the spot light. This is done by sampling shadow map texture and comparing the result with the scene depth.</p>
<div class="fragment"><div class="line">    <span class="comment">/* Depth value retrieved from the shadow map. */</span></div>
<div class="line">    <span class="keywordtype">float</span> shadowMapDepth = textureProj(<a class="code" href="render__scene__shader_8frag.html#a158a18978e217c5df2058138645148a5">shadowMap</a>, normalizedVertexPositionInTexture);</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Depth value retrieved from drawn model. */</span></div>
<div class="line">    <span class="keywordtype">float</span> modelDepth = normalizedVertexPositionInTexture.z;</div>
</div><!-- fragment --><p> If the fragment is inside the light cone and not in the shadow, the projected texture colour should be applied on it.</p>
<div class="fragment"><div class="line"></div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> <a class="code" href="render__scene__shader_8frag.html#ab962fe36b14955550df17a1c88a6f2c9" title="Get projected texture colour sampled for a specific fragment.">calculateProjectedTexture</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> <a class="code" href="_e_t_c_atlas_alpha_8h.html#aadd4a353b19613f2fb7b23ee69ae25bc">textureCoordinates</a>           = (<a class="code" href="render__scene__shader_8frag.html#a282ca3e6f859f215f33b765ebeebf9ba">viewToColorTextureMatrix</a> * <a class="code" href="render__scene__shader_8frag.html#ad30d70f8f7dda21aec3d393073308afe">vertexInEyeSpace</a>).xyz;</div>
<div class="line">    <a class="code" href="structvec3.html">vec3</a> normalizedTextureCoordinates = <a class="code" href="matrix_8h.html#afec26b6e42064ef2316f1be013515801">normalize</a>(textureCoordinates);</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> textureColor                 = textureProj(<a class="code" href="render__scene__shader_8frag.html#ac56d8bc38d502ac44e07056c4a47c508">colorTexture</a>, normalizedTextureCoordinates);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> textureColor;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"></div>
<div class="line"><a class="code" href="structvec4.html">vec4</a> <a class="code" href="render__scene__shader_8frag.html#a61e6552ff6957d42a4013be81b1bb2b4" title="Get the spot lighting factor.">calculateSpotLight</a>(<span class="keywordtype">float</span> fragmentToLightCosValue)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> constantAttenuation  = 0.01;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> linearAttenuation    = 0.001;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> quadraticAttenuation = 0.0004;</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a>        result               = <a class="code" href="structvec4.html">vec4</a>(0.0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Calculate the distance from a spot light source to fragment. */</span></div>
<div class="line">    <span class="keywordtype">float</span> distance             = distance(vertexInEyeSpace.xyz, <a class="code" href="render__scene__shader_8frag.html#ac9bf33d38dd684aa1d831d66b38168f9">spotLightPositionInEyeSpace</a>.<a class="code" href="structvec4.html#a7393f7525715d33e4dc5b79ebeb275fb">xyz</a>);</div>
<div class="line">    <span class="keywordtype">float</span> factor               = <a class="code" href="noise_8cpp.html#ade5e5a7c2668edda2637fd3bdadb85e5">clamp</a>((fragmentToLightCosValue - <a class="code" href="render__scene__shader_8frag.html#aeb60c831a56d27a0777d040001bdc9ef">spotLightCosAngle</a>), 0.0, 1.0);</div>
<div class="line">    <span class="keywordtype">float</span> attenuation          = 1.0 / (constantAttenuation             +</div>
<div class="line">                                        linearAttenuation    * distance +</div>
<div class="line">                                        quadraticAttenuation * distance * distance);</div>
<div class="line">    <a class="code" href="structvec4.html">vec4</a> projectedTextureColor = <a class="code" href="render__scene__shader_8frag.html#ab962fe36b14955550df17a1c88a6f2c9" title="Get projected texture colour sampled for a specific fragment.">calculateProjectedTexture</a>();</div>
<div class="line"></div>
<div class="line">    result = (<a class="code" href="render__scene__shader_8frag.html#aa919d2c3130a764dab20486c01941bbf">spotLightColor</a> * 0.5 + projectedTextureColor)* factor * attenuation;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Apply spot lighting and shadowing if needed). */</span></div>
<div class="line">    <span class="keywordflow">if</span> ((fragmentToLightCosValue &gt; <a class="code" href="render__scene__shader_8frag.html#aeb60c831a56d27a0777d040001bdc9ef">spotLightCosAngle</a>) &amp;&amp; <span class="comment">/* If fragment is in spot light cone. */</span></div>
<div class="line">         modelDepth &lt; shadowMapDepth + <a class="code" href="render__scene__shader_8frag.html#a002b2f4894492820fe708b1b7e7c5e70">EPSILON</a>)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="structvec4.html">vec4</a> spotLighting = <a class="code" href="render__scene__shader_8frag.html#a61e6552ff6957d42a4013be81b1bb2b4" title="Get the spot lighting factor.">calculateSpotLight</a>(fragmentToLightCosValue);  </div>
<div class="line"></div>
<div class="line">        <a class="code" href="simple__framework_2fonts_2opengles__30_2font_8frag.html#a0a3e99eab94835ffca469f09cb4a24ef">color</a> += spotLighting;</div>
<div class="line">    }</div>
</div><!-- fragment --><p> After those operations are applied, we get the result as shown on the images below.</p>
<div class="image">
<img src="ProjectedLightsResult.png" alt="ProjectedLightsResult.png"/>
<div class="caption">
The result of the rendering: when only the directional lighting is applied (on the left) and when projected lights are applied (on the right).</div></div>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2013</a>
    </li>
  </ul>
</div>
</body>
</html>
